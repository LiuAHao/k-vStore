
```markdown:/home/liuahao/k-vStore/README
# 基于 Raft 的分布式键值存储系统 C++ 框架设计

## 整体架构示意图
```
+----------------+       RPC 通信        +----------------+
|   Client       | <------------------> |   KvServer     |
+----------------+                       +----------------+
                                           |  |  ▲
                                           |  |  |
                                           v  v  |
+----------------+       Raft 协议通信     +----------------+
|   RaftNode     | <------------------> |   RaftNode     |
+----------------+                       +----------------+
        |                                       |
        v                                       v
+----------------+                      +----------------+
| e KvStateMachin| <-- 状态复制 ------> | KvStateMachine |
+----------------+                      +----------------+
        |                                       |
        v                                       v
+----------------+                      +----------------+
|   LevelDB      |                      |   LevelDB      |
+----------------+                      +----------------+
```

---

## 键值数据库连接逻辑

### 1. 数据存储层设计

#### 1.1 LevelDB 作为底层存储引擎
系统使用 LevelDB 作为底层键值存储引擎，提供高性能的本地数据存储能力：

```cpp
// KvStateMachine 中的数据库初始化
KvStateMachine::KvStateMachine() {
    // 初始化LevelDB
    leveldb::Options options;
    options.create_if_missing = true;
    
    leveldb::Status status = leveldb::DB::Open(options, "/tmp/kvstore_db", &database);
    if (!status.ok()) {
        std::cerr << "无法打开数据库: " << status.ToString() << std::endl;
        database = nullptr;
    }
}
```

#### 1.2 持久化存储设计
系统使用 `PersistentStorage` 类管理 Raft 算法相关的持久化数据：

```cpp
class PersistentStorage {
private:
    std::string dbPath;
    leveldb::DB* db;  // LevelDB 数据库实例

public:
    // 构造函数接收数据库路径
    PersistentStorage(const std::string& path);
    
    // 持久化操作
    bool saveTerm(int64_t term);
    bool saveVote(int64_t candidateId);
    bool saveLogs(const std::vector<LogEntry>& logs);
    
    // 加载操作
    int64_t loadTerm();
    int64_t loadVote();
    std::vector<LogEntry> loadLogs();
};
```

### 2. 数据操作流程

#### 2.1 写入操作流程
客户端写入数据的完整流程：

1. 客户端通过 `KvClient` 发送写请求到任意节点
   ```cpp
   KvClient client(serverAddresses);
   client.set("user_key", "user_value");
   ```

2. `KvServer` 接收请求并创建日志条目
   ```cpp
   bool KvServer::set(const std::string& key, const std::string& value) {
       // 创建一个SET类型的日志条目
       LogEntry entry(LogEntry::Type::SET, key, value, requestId++, term, index++);
       stateMachine.apply(ery);
       return true;
   }
   ```

3. 日志条目应用到状态机
   ```cpp
   void KvStateMachine::apply(const LogEntry& entry) {
       switch (entry.getType()) {
           case LogEntry::Type::SET:
               database->Put(leveldb::WriteOptions(), entry.getKey(), entry.getValue());
               break;
           // 其他操作类型...
       }
   }
   ```

#### 2.2 读取操作流程
客户端读取数据的流程：

1. 客户端发送读请求nt
   ```cpp
   std::string value = client.get("user_key");
   ```

2. `KvServer` 处理读请求
   ```cpp
   std::string KvServer::get(const std::string& key) {
       // 直接从状态机获取数据
       return stateMachine.get(key);
   }
   ```

3. 状态机从 LevelDB 读取数据
   ```cpp
   std::string KvStateMachine::get(const std::string& key) {
       std::string value;
       leveldb::Status status = database->Get(leveldb::ReadOptions(), key, &value);
       
       if (status.ok()) {
           return value;
       } else if (status.IsNotFound()) {
           return ""; // 键不存在
       } else {
           std::cerr << "GET操作失败: " << status.ToString() << std::endl;
           return "";
       }
   }
   ```

### 3. 日志条目设计

系统使用 `LogEntry` 类表示操作日志，包含以下关键字段：

```cpp
class LogEntry {
public:
    enum class Type { SET, GET, DELETE, NOOP };
    Type type;
    std::string key;    // 操作的键（GET/SET/DELETE 时使用）
    std::string value;  // 操作的值（仅 SET 时使用）
    int64_t requestId;  // 客户端请求唯一ID（用于幂等性）
    int64_t term;       // 日志对应的任期号（Raft 关键字段）
    int64_t index;      // 日志在全局的顺序索引
    
    // 序列化与反序列化方法
    std::string serialize() const;
    static LogEntry deserialize(const std::string& data);
};
```

日志序列化格式：
```
type|key|value|requestId|term|index
```

例如：
```
0|user_name|Alice|1001|5|42
```

### 4. 客户端连接管理

`KvClient` 类管理与服务器的连接，并处理重试和故障转移：

```cpp
class KvClient {
private:
    std::string currentAddress;
    std::vector<std::string> servers;
    size_t currentServerIndex;
    
public:
    KvClient(std::vector<std::string>& servers);
    
    // 客户端操作
    bool set(const std::string& key, const std::string& value);
    std::string get(const std::string& key);
    bool deleteKey(const std::string& key);
    
    // 服务器切换
    void rotateServer();    // 切换到下一个服务器
};
```

当请求失败时，客户端会自动切换到下一个服务器：

```cpp
void KvClient::rotateServer() {
    currentServerIndex = (currentServerIndex + 1) % servers.size();
    currentAddress = servers[currentServerIndex];
    std::cout << "切换到服务器: " << currentAddress << std::endl;
}
```

### 5. 数据存储路径规划

在实际部署中，系统使用以下路径结构：

```
/var/kvstore/               # 主目录
  ├── node1/                # 节点1数据
  │   ├── raft_logs         # Raft 日志和元数据
  │   └── kv_data           # 键值数据存储
  ├── node2/                # 节点2数据
  └── ...
```

每个节点的数据库路径在初始化时指定：

```cpp
// 初始化持久化存储
PersistentStorage storage("/var/kvstore/node1/raft_logs");

// 初始化键值状态机
KvStateMachine stateMachine("/var/kvstore/node1/kv_data");
```

### 6. 数据一致性保证

系统通过以下机制确保数据一致性：

1. **写入操作**：所有写入必须通过 Raft 日志复制，确保多数节点确认
2. **读取操作**：当前实现从本地状态机读取，在完整 Raft 实现中需要通过 ReadIndex 或 LeaderLease 确保线性一致性
3. **幂等性**：使用 requestId 确保相同请求只被应用一次

## 核心类定义及功能说明

### 1. `LogEntry` 类 - 日志条目
```cpp
class LogEntry {
public:
    enum class Type { SET, GET, DELETE, NOOP };
    Type type;
    std::string key;    // 操作的键
    std::string value;  // 操作的值
    int64_t requestId;  // 客户端请求唯一ID
    int64_t term;       // 日志对应的任期号
    int64_t index;      // 日志在全局的顺序索引
    
    // 序列化与反序列化方法
    std::string serialize() const;
    static LogEntry deserialize(const std::string& data);
};
```

### 2. `KvStateMachine` 类 - 键值存储状态机
```cpp
class KvStateMachine {
private:
    leveldb::DB* database;      // 数据库实例
public:
    KvStateMachine();
    ~KvStateMachine();
    void apply(const LogEntry& entry);
    std::string get(const std::string& key);
};
```

### 3. `KvServer` 类 - 键值服务接口层
```cpp
class KvServer {
private:
    std::string address;
    std::string port;
    KvStateMachine stateMachine;    // 键值存储状态机
    std::mutex pendingReqMutex;     // 用于保护 pendingRequests 的互斥锁
    std::map<int, std::string> pendingRequests;     // 存储未完成的请求

public:
    KvServer(const std::string& address, const std::string& port);
    ~KvServer();
    
    std::string get(const std::string& key);
    bool set(const std::string& key, const std::string& value);
    bool deleteKey(const std::string& key);
};
```

### 4. `PersistentStorage` 类 - 持久化存储
```cpp
class PersistentStorage {
private:
    std::string dbPath;
    leveldb::DB* db;  // LevelDB 数据库实例

public:
    PersistentStorage(const std::string& path);
    ~PersistentStorage();
    
    bool saveTerm(int64_t term);         // 保存当前任期
    bool saveVote(int64_t candidateId);  // 保存投票记录
    bool saveLogs(const std::vector<LogEntry>& logs); // 保存日志
    
    int64_t loadTerm();                  // 加载当前任期
    int64_t loadVote();                  // 加载投票记录
    std::vector<LogEntry> loadLogs();    // 加载日志
};
```

### 5. `KvClient` 类 - 客户端接口
```cpp
class KvClient {
private:
    std::string currentAddress;
    std::vector<std::string> servers;
    size_t currentServerIndex;
    
public:
    KvClient(std::vector<std::string>& servers);
    ~KvClient();
    
    bool set(const std::string& key, const std::string& value);
    std::string get(const std::string& key);
    bool deleteKey(const std::string& key);
    void rotateServer();    // 切换到下一个服务器
};
```

## 数据库设计建议

1. **使用 LevelDB 作为存储引擎**  
   系统使用 LevelDB 作为键值存储引擎，提供高性能的本地数据存储：
   ```cpp
   #include <leveldb/db.h>
   leveldb::DB* db;
   leveldb::Options options;
   options.create_if_missing = true;
   leveldb::Status status = leveldb::DB::Open(options, "/tmp/kvstore_db", &db);
   ```

2. **数据分区与扩展**  
   在大规模部署时，可以考虑按键范围进行分区：
   ```
   分区1: 键范围 [A-M]
   分区2: 键范围 [N-Z]
   ```
   每个分区由独立的 Raft 组管理，提高系统整体吞吐量。

3. **数据备份与恢复**  
   定期对 LevelDB 数据文件进行备份，可以使用 LevelDB 的快照功能：
   ```cpp
   // 创建快照
   const leveldb::Snapshot* snapshot = db->GetSnapshot();
   // 使用快照进行读取
   leveldb::ReadOptions options;
   options.snapshot = snapshot;
   // 释放快照
   db->ReleaseSnapshot(snapshot);
   ```

## 后续开发计划

1. 实现完整的 Raft 算法，包括领导者选举、日志复制和成员变更
2. 添加快照机制，优化大规模数据恢复性能
3. 实现线性一致性读取，确保读操作的一致性
4. 添加监控和管理接口，方便系统运维
```

